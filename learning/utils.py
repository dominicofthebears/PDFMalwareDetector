import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import seaborn as sn
from sklearn import tree


# test_val means if the results are relative to validation or test set
def save_results(clf_name, conf_matrix, cr, test_val):
    metrics_results = ("Benign" + ' : ' + str(cr["Benign"]) + '\n')
    metrics_results += ("Malicious" + ' : ' + str(cr["Malicious"]) + '\n')
    for key, value in cr.items():
        if key != "Benign" and key != "Malicious":
            metrics_results += (str(key) + ' : ' + str(value) + '\n')
    to_print = metrics_results + "--------------------------------;" + '\n' + str(
        conf_matrix)
    f = open("../models/results/" + test_val + '/' + clf_name + "_" + test_val + ".csv", "w")
    f.write(to_print)
    f.close()


def save_rules(rules, clf):
    f = open("../models/rules/" + clf + "_rules.txt", "w")
    for rule in rules:
        f.write(rule + "\n")
    f.close()


def get_rules(input_tree, feature_names, class_names):
    tree_ = input_tree.tree_
    feature_name = [
        feature_names[i] if i != tree._tree.TREE_UNDEFINED else "undefined!"
        for i in tree_.feature
    ]

    paths = []
    path = []

    def recurse(node, path, paths):
        if tree_.feature[node] != tree._tree.TREE_UNDEFINED:
            name = feature_name[node]
            threshold = tree_.threshold[node]
            p1, p2 = list(path), list(path)
            p1 += [f"({name} <= {np.round(threshold, 3)})"]
            recurse(tree_.children_left[node], p1, paths)
            p2 += [f"({name} > {np.round(threshold, 3)})"]
            recurse(tree_.children_right[node], p2, paths)
        else:
            path += [(tree_.value[node], tree_.n_node_samples[node])]
            paths += [path]

    recurse(0, path, paths)

    # sort by samples count
    samples_count = [p[-1][1] for p in paths]
    ii = list(np.argsort(samples_count))
    paths = [paths[i] for i in reversed(ii)]

    rules = []
    for path in paths:
        rule = "if "

        for p in path[:-1]:
            if rule != "if ":
                rule += " and "
            rule += str(p)
        rule += " then "
        if class_names is None:
            rule += "response: " + str(np.round(path[-1][0][0][0], 3))
        else:
            classes = path[-1][0][0]
            l = np.argmax(classes)
            rule += f"class: {class_names[l]}"
        rules += [rule]

    return rules


def datasets_distribution():
    cl_train = pd.read_csv("../datasets/CategoricalTraininingSet.csv")
    cl_test = pd.read_csv("../datasets/CategoricalTestSet.csv")

    labels = ['Training set', 'Test set']
    benign = [cl_train.iloc[:, -1].value_counts()["Benign"], cl_test.iloc[:, -1].value_counts()["Benign"]]
    malicious = [cl_train.iloc[:, -1].value_counts()["Malicious"], cl_test.iloc[:, -1].value_counts()["Malicious"]]

    x = np.arange(len(labels))
    width = 0.30  # the width of the bars

    fig, ax = plt.subplots()
    rects1 = ax.bar(x - width / 2, benign, width, label='Benign')
    rects2 = ax.bar(x + width / 2, malicious, width, label='Malicious')

    ax.set_ylabel('Values')
    ax.set_xticks(x)
    ax.set_xticklabels(labels)
    ax.legend()

    plt.show()


def heatmaps():
    array = [[1313,   27], 
            [63, 1604]]

    df_cm = pd.DataFrame(array, range(2), range(2))
    sn.set(font_scale=1.4)
    plt.title("CN2 Learner")
    sn.heatmap(df_cm, annot=True, fmt='g',annot_kws={"size": 16}, cmap="Blues")  # font size

    plt.show()


