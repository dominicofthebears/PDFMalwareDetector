from functools import reduce
import pandas as pd
from mlxtend.frequent_patterns import apriori, association_rules
from mlxtend.preprocessing import TransactionEncoder
from learning.utils import save_rules

"""
    since association rules won't be used for classification, this part will not be replicated on
    the surrogated training set. This will be used for comparison with other produced rules from main models
"""
def make_association_rules():
    dataframe = pd.read_csv("../datasets/CategoricalTraininingSet.csv")
    for column in dataframe.columns:
        if column == "Class":
            dataframe[column] = dataframe[column].apply(lambda x: f'{column} = {x}')
        else:
            dataframe[column] = dataframe[column].apply(lambda x: f'{column} in range {x}')
    te = TransactionEncoder()
    te_data = te.fit(dataframe.values).transform(dataframe.values)
    df = pd.DataFrame(te_data, columns=te.columns_)
    freq_itemset = apriori(df, min_support=0.2, use_colnames=True)

    rules = association_rules(freq_itemset, metric="lift", min_threshold=1.2)
    data = pd.DataFrame(rules)
    output_rules = []
    for i in range(0, len(data)):
        antecedents = list(data.antecedents[i])
        consequents = list(data.consequents[i])

        if (not ("Class = Benign" in antecedents)) and (not ("Class = Malicious" in antecedents)) \
                and (("Class = Benign" in consequents) or ("Class = Malicious" in consequents)):
            ant = "IF "
            ant += reduce(lambda a, b: a + " AND " + b, antecedents) + " THEN "
            cons = reduce(lambda a, b: a + " AND " + b, consequents)
            rule = ant + cons
            output_rules.append(rule)
    save_rules(output_rules, "FrequentPatternMining")


if __name__ == '__main__':
    make_association_rules()
