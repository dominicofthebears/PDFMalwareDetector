import numpy as np


def equalObs(x, nbin):
    nlen = len(x)
    return np.interp(np.linspace(0, nlen, nbin + 1),
                     np.arange(nlen),
                     np.sort(x))


def equal_frequency_binning(data, test, bins, disc_type):
    for column in data.columns:
        if column != 'text' and column != 'header':
            data[column] = data[column].astype(float)
            cutoffs = equalObs((data[column]), bins)
            for i in range(0, bins):
                if i == bins - 1:
                    if disc_type == "categorical":
                        val = "[" + str(cutoffs[i]) + " - " + str(cutoffs[i + 1]) + "]"
                        data[column] = data[column].apply(
                            lambda x: val if type(x) != str and cutoffs[i] <= x <= cutoffs[i + 1] else x)
                        test[column] = test[column].apply(
                            lambda x: val if type(x) != str and cutoffs[i] <= x <= cutoffs[i + 1] else x)
                    # this else conteplates the case in which we want to encode the dataset in a continuous way by using the mean point of each bin
                    else:
                        val = (cutoffs[i] + cutoffs[i + 1]) / 2
                        data[column] = data[column].apply(lambda x: val if cutoffs[i] <= x <= cutoffs[i + 1] else x)
                        test[column] = test[column].apply(lambda x: val if cutoffs[i] <= x <= cutoffs[i + 1] else x)
                else:
                    if disc_type == "categorical":
                        val = "[" + str(cutoffs[i]) + " - " + str(cutoffs[i + 1]) + "["
                        data[column] = data[column].apply(
                            lambda x: val if type(x) != str and cutoffs[i] <= x < cutoffs[i + 1] else x)
                        test[column] = test[column].apply(
                            lambda x: val if type(x) != str and cutoffs[i] <= x < cutoffs[i + 1] else x)
                    else:
                        val = (cutoffs[i] + cutoffs[i + 1]) / 2
                        data[column] = data[column].apply(lambda x: val if cutoffs[i] <= x < cutoffs[i + 1] else x)
                        test[column] = test[column].apply(lambda x: val if cutoffs[i] <= x < cutoffs[i + 1] else x)
    return data, test


def equal_width_binning(dataframe, test, num_bins, disc_type):
    for col in dataframe.columns:
        if col != 'text' and col != 'header':
            dataframe[col] = dataframe[col].astype(float)
            maximum = max(dataframe[col])
            minimum = min(dataframe[col])
            w = (maximum - minimum) / num_bins
            left = minimum
            right = w
            for i in range(0, num_bins):
                if right == maximum:
                    if disc_type == "categorical":
                        val = '[' + str(int(left)) + ' - ' + str(int(right)) + ']'  # casting to int for cosmetic reason
                        dataframe[col] = dataframe[col].apply(
                            lambda x: val if type(x) != str and left <= x <= right else x)
                        test[col] = test[col].apply(lambda x: val if type(x) != str and left <= x <= right else x)
                    else:
                        val = int((left + right) / 2)
                        dataframe[col] = dataframe[col].apply(lambda x: val if left <= x <= right else x)
                        test[col] = test[col].apply(lambda x: val if left <= x <= right else x)
                else:
                    if disc_type == "categorical":
                        val = '[' + str(int(left)) + ' - ' + str(int(right)) + '['  # upper bound not included in bin
                        dataframe[col] = dataframe[col].apply(
                            lambda x: val if type(x) != str and left <= x < right else x)
                        test[col] = test[col].apply(lambda x: val if type(x) != str and left <= x < right else x)
                    else:
                        val = int((left + right) / 2)
                        dataframe[col] = dataframe[col].apply(lambda x: val if left <= x < right else x)
                        test[col] = test[col].apply(lambda x: val if left <= x < right else x)
                left += w
                right += w
    return dataframe, test
